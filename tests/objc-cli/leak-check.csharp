#!/usr/bin/env /Library/Frameworks/Mono.framework/Commands/csharp

using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;

var args = Environment.GetCommandLineArgs ();

if (args.Length < 2) {
	Console.WriteLine ("A command must be specified");
	Environment.Exit (1);
	return;
}

var ready_file = Path.GetFullPath (".stamp-ready"); // this file is removed when the test app is ready for leak check
var done_file = Path.GetFullPath (".stamp-done"); // this file is removed when the leak check is complete, this means the test app can exit

File.WriteAllText (ready_file, string.Empty);
File.WriteAllText (done_file, string.Empty);

Environment.SetEnvironmentVariable ("LEAK_READY_FILE", ready_file);
Environment.SetEnvironmentVariable ("LEAK_DONE_FILE", done_file);

using (var p = new Process ()) {
	p.StartInfo.FileName = args [2];
	var sb = new StringBuilder ();
	for (int i = 3; i < args.Length; i++)
		sb.Append (" \"").Append (args [i]).Append ("\"");
	p.StartInfo.Arguments = sb.ToString ();
	p.StartInfo.Environment.Add ("MallocStackLogging", "1");
	p.StartInfo.Environment.Add ("MallocScribble", "1");
	p.StartInfo.UseShellExecute = false;
	Console.WriteLine ("Executing: {0} {1}", p.StartInfo.FileName, p.StartInfo.Arguments);
	p.Start ();

	while (File.Exists (ready_file)) {
		Console.WriteLine ("Waiting for app to become ready for leak test...");
		Thread.Sleep (1000);
	}

	Console.WriteLine ("Performing leak test...");
	using (var leaks = new Process ()) {
		leaks.StartInfo.FileName = "xcrun";
		leaks.StartInfo.Arguments = $"leaks {p.Id}";
		leaks.StartInfo.UseShellExecute = false;
		leaks.Start ();
		leaks.WaitForExit ();
	}
	Console.WriteLine ("Done performing leak test.");

	File.Delete (done_file);

	Console.WriteLine ("Waiting for app to terminate...");

	p.WaitForExit ();

	Console.WriteLine ("Done");
}

Environment.Exit (0);
return;